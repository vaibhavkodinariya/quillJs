<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quill â€” Image + Caption (Custom Resizer Only)</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.css">

<style>
:root{--card-bg:#fff; --page-bg:#f6f7fb; --text:#2c3e50; --muted:#98a2b3; --ring:#dbe6ff; --ring-strong:#9ec5ff; --button-bg:#fafafa; --button-border:#e4e7ec; --button-hover:#eef4ff; --button-active:#cfe2ff; --shadow:0 10px 30px rgba(0,0,0,0.08);} 
*{box-sizing:border-box}
body{background:var(--page-bg);font-family:"Segoe UI", Roboto, system-ui, -apple-system, Arial, sans-serif;display:flex;justify-content:center;padding:42px 12px;color:var(--text)}
.editor-card{width:100%;max-width:1080px;border-radius:18px;background:var(--card-bg);box-shadow:var(--shadow);border:1px solid #eef0f4;position:relative}
.ql-toolbar.ql-snow{display:flex;flex-wrap:wrap;gap:6px;padding:8px 12px;border:none;border-bottom:1px solid #eee;background:#fff;align-items:center;box-shadow:0 2px 4px rgba(0,0,0,0.04);border-radius:18px 18px 0 0}
.ql-toolbar .ql-formats{background:#fff;border:1px solid var(--button-border);border-radius:12px;padding:4px;display:flex;align-items:center;gap:2px}
.ql-toolbar.ql-snow button{height:32px;width:32px;border-radius:6px;display:flex;align-items:center;justify-content:center;transition:background .2s}
.ql-toolbar.ql-snow button:hover{background:#f5f5f5}
.ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label{border: none !important;}
.ql-toolbar .ql-picker{height:32px;min-width:35px;font-size:14px;border-radius:6px;display:flex;align-items:center}
.ql-toolbar .ql-picker-label{display:flex;align-items:center;padding:0 8px}
.ql-toolbar .ql-picker-options{border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.1)}
.ql-toolbar button svg{width:16px;height:16px}
.ql-container.ql-snow{border:none;border-radius:0 0 14px 14px;box-shadow: inset 0 0 0 1px #eee}
.ql-editor{min-height:540px;font-size:17px;line-height:1.8;color:var(--text);background:#fff;border-radius:0 0 14px 14px;position:relative}
.ql-editor.ql-blank::before{color:#a3aab7;font-style:italic}
.ql-editor img,.ql-editor video{border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.08);margin:1rem auto;display:block;max-width:100%}
.video-resize-handle{width:12px;height:12px;background:#2196f3;position:absolute;right:0;bottom:0;cursor:nwse-resize;z-index:10;border-radius:3px}
.ql-snow .ql-table-better{align-items:center;padding:6px 10px;font-size:14px;border-radius:6px}
#char-count{position:absolute;bottom:-80px;right:16px;background:rgba(0,0,0,0.05);color:#555;padding:4px 10px;border-radius:12px;font-size:13px;pointer-events:none}
.ql-custom-tooltip{position:fixed;pointer-events:none;background:rgba(20,20,20,0.95);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;transform:translateY(-8px);transition:opacity .12s ease, transform .12s ease;opacity:0;z-index:9999;white-space:nowrap;box-shadow:0 6px 20px rgba(0,0,0,0.25)}
.ql-custom-tooltip.visible{opacity:1;transform:translateY(0)}
.ql-caption {
  display: block;
  margin: 6px auto 0;
  box-sizing: border-box;
  max-width: 100%;
  white-space: normal;
  text-align: center;
}
.ql-caption:focus{outline:none;box-shadow:0 0 0 3px rgba(66,153,225,0.12)}
.quill-modal-overlay{position:fixed;inset:0;background:rgba(10,10,10,0.45);display:none;align-items:center;justify-content:center;z-index:11000}
.quill-modal-overlay.active{display:flex}
.quill-modal{width:520px;max-width:calc(100% - 32px);background:#fff;border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.25);font-size:14px}
.quill-modal h3{Margin:0 0 10px;font-size:16px;color:var(--text)}
.quill-modal .row{display:flex;gap:10px;margin-bottom:10px;align-items:center}
.quill-modal label{display:block;width:100%;font-size:13px;color:var(--muted)}
.quill-modal input[type="text"],.quill-modal input[type="file"],.quill-modal textarea{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e6e9ee;background:#fbfbfb;font-size:14px}
.quill-modal .preview{width:100%;height:220px;border-radius:8px;background:#fafafa;display:flex;align-items:center;justify-content:center;overflow:hidden;border:1px dashed #e6e9ee}
.quill-modal .preview img,.quill-modal .preview video{max-width:100%;max-height:100%;display:block}
.quill-modal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
.btn{padding:8px 12px;border-radius:8px;border:1px solid var(--button-border);background:var(--button-bg);cursor:pointer}
.btn.primary{background:linear-gradient(180deg,#1e90ff,#147de8);color:#fff;border:1px solid rgba(0,0,0,0.08)}
.btn.ghost{background:transparent}
@media (max-width:520px){.quill-modal{padding:12px}.quill-modal .preview{height:160px}}
.editor-card.drag-over{outline:3px dashed rgba(30,144,255,0.22);box-shadow:0 12px 36px rgba(20,50,120,0.06)}
.ql-editor.drag-target{background-image:linear-gradient(90deg,rgba(30,144,255,0.03),rgba(30,144,255,0.01))}
.ql-hr { box-sizing: content-box; height: 0; border: 0; border-top: 1px solid #DFE3E7; }

/* custom figure wrapper styling & toolbar */
figure.custom-figure {
  display: block;
  position: relative;
  margin: 12px 0;
  padding: 6px;
  text-align: center;
  vertical-align: top;
  box-sizing: border-box;
  max-width: 100%;
  border-radius: 6px;
  width: 320px;
}
figure.custom-figure img,
figure.custom-figure video { display:block; width:100%; height:auto; margin:0 auto; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.08); }
figure.custom-figure .fig-resize-handle { position:absolute; right:8px; bottom:8px; width:14px; height:14px; background:#fff; border:1px solid #888; cursor:se-resize; border-radius:3px; z-index:40; }
figure.custom-figure .fig-resize-handle:after { content:""; display:block; width:8px; height:8px; margin:2px; border-right:2px solid #666; border-bottom:2px solid #666; }
.figure-toolbar {
  position: absolute;
  top: -40px;
  right: 0;
  display: flex;
  gap: 6px;
  background: #fff;
  border: 1px solid #ddd;
  padding: 4px;
  border-radius: 6px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  z-index: 60;
  font-size: 13px;
}
.figure-toolbar button { background: transparent; border: 0; padding: 6px 8px; cursor: pointer; border-radius:4px; }
.figure-toolbar button:hover { background:#f2f6fb; }
figure.align-left { margin-left: 0; margin-right: auto; text-align: left; }
figure.align-center { margin-left: auto; margin-right: auto; text-align: center; }
figure.align-right { margin-left: auto; margin-right: 0; text-align: right; }
</style>
</head>
<body>
<div class="editor-card">
  <div id="root"></div>
  <div id="char-count">Characters: 0</div>
</div>

<!-- Image modal -->
<div id="quill-image-modal-overlay" class="quill-modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="quill-modal" role="document" aria-labelledby="quill-image-modal-title">
    <h3 id="quill-image-modal-title">Insert image (optional caption)</h3>
    <div class="row">
      <label>Image URL<input id="quill-image-url" type="text" placeholder="https://example.com/image.jpg" /></label>
    </div>
    <div class="row">
      <label>Or upload file<input id="quill-image-file" type="file" accept="image/*" /></label>
    </div>
    <div class="row">
      <label>Caption (optional)<input id="quill-image-caption" type="text" placeholder="Write a caption (optional)" /></label>
    </div>
    <div class="row"><div class="preview" id="quill-image-preview">Preview</div></div>
    <div class="actions">
      <button id="quill-image-cancel" class="btn ghost" type="button">Cancel</button>
      <button id="quill-image-insert" class="btn primary" type="button">Insert</button>
    </div>
  </div>
</div>

<!-- Video modal -->
<div id="quill-video-modal-overlay" class="quill-modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="quill-modal" role="document" aria-labelledby="quill-video-modal-title">
    <h3 id="quill-video-modal-title">Insert video (optional caption)</h3>
    <div class="row">
      <label>Video URL<input id="quill-video-url" type="text" placeholder="https://example.com/video.mp4" /></label>
    </div>
    <div class="row">
      <label>Or upload file<input id="quill-video-file" type="file" accept="video/*" /></label>
    </div>
    <div class="row">
      <label>Caption (optional)<input id="quill-video-caption" type="text" placeholder="Write a caption (optional)" /></label>
    </div>
    <div class="row"><div class="preview" id="quill-video-preview">Preview</div></div>
    <div class="actions">
      <button id="quill-video-cancel" class="btn ghost" type="button">Cancel</button>
      <button id="quill-video-insert" class="btn primary" type="button">Insert</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
<script src="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.js"></script>

<script>
/* ---------------------------
   Setup / Register modules (NO external resize module)
   --------------------------- */
const Icons = Quill.import('ui/icons');
Icons['undo'] = `<svg viewBox="0 0 24 24"><path d="M7 7v4H3M3 11a9 9 0 1 1 3 6.7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
Icons['redo'] = `<svg viewBox="0 0 24 24"><path d="M17 7v4h4M21 11a9 9 0 1 0-3 6.7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
Icons['hr'] = `<svg viewBox="0 0 24 24" width="16" height="16">
  <line x1="4" y1="12" x2="20" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>`;

if (window.QuillTableBetter) Quill.register({ 'modules/table-better': QuillTableBetter }, true);

/* ---------------------------
   Horizontal rule blot
   --------------------------- */
const BlockEmbed = Quill.import('blots/block/embed');
class HorizontalLineBlot extends BlockEmbed {
  static create() {
    const node = super.create();
    node.setAttribute('contenteditable', false);
    return node;
  }
}
HorizontalLineBlot.blotName = 'hr';
HorizontalLineBlot.tagName = 'hr';
HorizontalLineBlot.className = 'ql-hr';
Quill.register(HorizontalLineBlot);

/* ---------------------------
   Caption blot (block)
   --------------------------- */
const Block = Quill.import('blots/block');
class CaptionBlot extends Block {
  static create(value = '') {
    const node = super.create();
    node.setAttribute('contenteditable', true);
    node.className = 'ql-caption';
    node.innerText = value || '';
    return node;
  }
  static value(node) {
    return node.innerText || '';
  }
}
CaptionBlot.blotName = 'caption';
CaptionBlot.tagName = 'div';
Quill.register(CaptionBlot);

/* ---------------------------
   NativeVideoBlot
   --------------------------- */
class NativeVideoBlot extends BlockEmbed {
  static create(value) {
    const node = super.create();
    node.setAttribute('contenteditable', false);
    const url = typeof value === 'string' ? value : (value && value.url) || '';
    const video = document.createElement('video');
    video.src = url;
    video.controls = true;
    video.playsInline = true;
    video.style.display = 'block';
    video.style.maxWidth = '100%';
    video.style.margin = '0 auto';
    node.appendChild(video);
    return node;
  }
  static value(node) {
    const v = node.querySelector('video');
    return v ? v.getAttribute('src') : '';
  }
}
NativeVideoBlot.blotName = 'nativeVideo';
NativeVideoBlot.tagName = 'div';
NativeVideoBlot.className = 'ql-native-video';
Quill.register(NativeVideoBlot);

/* ---------------------------
   FigureBlot (image/video + editable caption) â€” custom
   --------------------------- */
function urlLooksLikeVideo(url) { return /\.(mp4|webm|ogg|mov|m4v|3gp)(\?.*)?$/i.test(url); }

class FigureBlot extends BlockEmbed {
  static blotName = 'figure';
  static tagName = 'figure';

  static create(value = {}) {
    const node = super.create();
    node.classList.add('custom-figure');
    node.setAttribute('contenteditable', 'false');

    const type = value.type || (urlLooksLikeVideo(value.url) ? 'video' : 'image');
    if (type === 'video') {
      const video = document.createElement('video');
      video.controls = true;
      video.playsInline = true;
      const source = document.createElement('source');
      source.src = value.url || '';
      video.appendChild(source);
      node.appendChild(video);
    } else {
      const img = document.createElement('img');
      img.src = value.url || '';
      img.alt = value.caption || '';
      img.setAttribute('draggable', 'false');
      node.appendChild(img);
    }

    const caption = document.createElement('figcaption');
    caption.setAttribute('contenteditable', 'true');
    caption.className = 'ql-caption';
    caption.innerText = value.caption || '';
    node.appendChild(caption);

    if (value.width) node.style.width = value.width;
    if (value.align) {
      node.classList.remove('align-left','align-center','align-right');
      node.classList.add('align-' + value.align);
    }

    return node;
  }

  static value(node) {
    const media = node.querySelector('img,video');
    const caption = node.querySelector('figcaption');
    const url = media ? (media.tagName.toLowerCase() === 'video' ? (media.querySelector('source')?.getAttribute('src') || '') : media.getAttribute('src')) : '';
    const type = media ? media.tagName.toLowerCase() : 'image';
    const width = node.style.width || '';
    const align = (node.classList.contains('align-left') && 'left') ||
                  (node.classList.contains('align-right') && 'right') || 'center';
    return { url, type, caption: (caption ? caption.innerText : ''), width, align };
  }
}
Quill.register(FigureBlot);

/* ---------------------------
   Initialize Quill editor (no imageResize/videoResize modules)
   --------------------------- */
const editor = new Quill('#root', {
  theme: 'snow',
  placeholder: 'Start writing your content...',
  modules: {
    toolbar: {
      container: [
        ['bold','italic','underline','strike'],
        ['blockquote','code-block'],
        [{ 'header': 1 }, { 'header': 2 }],
        [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }],
        [{ 'script': 'sub'}, { 'script': 'super' }],
        [{ 'indent': '-1'},{ 'indent': '+1' }],
        [{ 'direction': 'rtl' }],
        [{ 'align': [] }],
        [{ 'size': ['small', false, 'large', 'huge'] }],
        [{ 'color': [] }, { 'background': [] }],
        [{ 'font': [] }],
        ['link','image','video','hr'],
        ['table-better'],
        ['clean'],
        ['undo','redo']
      ],
      handlers: {
        undo: () => editor.history.undo(),
        redo: () => editor.history.redo()
      }
    },
    history: { delay: 1000, maxStack: 500, userOnly: true },
    'table-better': { toolbarTable: true, menus: ['column','row','merge','table','cell','wrap','copy','delete'] },
    keyboard: { bindings: window.QuillTableBetter ? QuillTableBetter.keyboardBindings : {} }
  }
});

window.__quill = editor;

/* ---------------------------
   Character count
   --------------------------- */
const charCountEl = document.getElementById('char-count');
function updateCharCount() {
  const text = editor.getText().replace(/\n$/, '');
  charCountEl.textContent = `Characters: ${text.length}`;
}
updateCharCount();
editor.on('text-change', updateCharCount);

/* ---------------------------
   Helpers & dedupe store & url utility
   --------------------------- */
const recentInserts = new Map();
const RECENT_TTL = 3000;
function markInserted(key) { if (!key) return; recentInserts.set(key, Date.now()); setTimeout(() => recentInserts.delete(key), RECENT_TTL + 200); }
function wasRecentlyInserted(key) { if (!key) return false; const t = recentInserts.get(key); return t && (Date.now() - t) < RECENT_TTL; }
function normalizeUrl(u) { try { const url = new URL(u, location.href); url.hash = ''; return url.toString(); } catch (err) { return String(u).trim(); } }
function urlLooksLikeImage(url) { return /\.(png|jpe?g|gif|webp|bmp|svg)(\?.*)?$/i.test(url); }

/* ---------------------------
   Blob tracker and cleanup
   --------------------------- */
const blobUrlTracker = new Set();
const domCleanupObserver = new MutationObserver((mutations) => {
  for (const m of mutations) {
    for (const node of m.removedNodes) {
      if (node.nodeType !== 1) continue;
      const videos = node.tagName === 'VIDEO' ? [node] : Array.from(node.querySelectorAll('video'));
      for (const v of videos) {
        try {
          const s = v.src || '';
          if (s && s.startsWith('blob:') && blobUrlTracker.has(s)) {
            try { URL.revokeObjectURL(s); } catch(e){}
            blobUrlTracker.delete(s);
          }
        } catch (e) {}
      }
    }
  }
});
domCleanupObserver.observe(document.querySelector('#root'), { childList: true, subtree: true });

/* ---------------------------
   Clipboard matchers -> insert FigureBlot
   --------------------------- */
try {
  const Clipboard = editor.getModule('clipboard');
  if (Clipboard && Clipboard.addMatcher) {
    const Delta = Quill.import('delta');

    Clipboard.addMatcher('IMG', (node, delta) => {
      const src = node.getAttribute('src') || '';
      if (!src) return delta;
      if (wasRecentlyInserted(normalizeUrl(src))) return new Delta();
      markInserted(normalizeUrl(src));
      return new Delta().insert({ figure: { url: src, type: 'image', caption: '' } }).insert('\n');
    });

    Clipboard.addMatcher('VIDEO', (node, delta) => {
      const src = node.getAttribute('src') || (node.querySelector('source') && node.querySelector('source').getAttribute('src')) || '';
      if (!src) return delta;
      if (wasRecentlyInserted(normalizeUrl(src))) return new Delta();
      markInserted(normalizeUrl(src));
      return new Delta().insert({ figure: { url: src, type: 'video', caption: '' } }).insert('\n');
    });
  }
} catch (e) { /* ignore */ }

/* ---------------------------
   attachMediaResizeSync (uses ResizeObserver)
   --------------------------- */
/* ---------------------------
   attachMediaResizeSync (stable, no loop)
   --------------------------- */
function attachMediaResizeSync(mediaEl, containerEl) {
  if (!mediaEl) return;
  const target = containerEl || mediaEl;
  if (target.__mediaResizeAttached) return;
  target.__mediaResizeAttached = true;

  // Guard to avoid re-entrant updates
  if (typeof target.__mediaResizeApplying === 'undefined') target.__mediaResizeApplying = false;

  const applyCaptionWidth = (widthPx) => {
    try {
      let next = mediaEl.nextSibling;
      while (next && next.nodeType !== 1) next = next.nextSibling;
      if (next && next.classList && next.classList.contains('ql-caption')) {
        // keep caption flexible instead of forcing pixel sizes that can bounce
        next.style.width = '100%';
        next.style.maxWidth = '100%';
        next.style.marginLeft = next.style.marginRight = 'auto';
        next.style.boxSizing = 'border-box';
      }
    } catch (err) { /* ignore */ }
  };

  const sync = () => {
    try {
      if (target.__mediaResizeApplying) return;
      // Measure the container (figure) when available â€” more stable than measuring the media
      const rectSource = (target.getBoundingClientRect && target.getBoundingClientRect()) ||
                         (mediaEl.getBoundingClientRect && mediaEl.getBoundingClientRect()) || { width: 0 };
      let widthPx = Math.round(rectSource.width || 0);

      // If computed style width is available and more reliable, try fallback
      if (!widthPx || widthPx === 0) {
        const cs = window.getComputedStyle(mediaEl);
        widthPx = parseInt(cs.width, 10) || 0;
      }

      // If nothing meaningful, set auto and bail
      if (!widthPx || widthPx <= 0) {
        if (target.style.width && target.style.width !== 'auto') {
          target.style.width = 'auto';
        }
        applyCaptionWidth(widthPx);
        return;
      }

      // Avoid writing the same value over & over (prevents observer feedback loops)
      const current = parseInt((target.style.width || '').replace('px', ''), 10) || 0;
      if (current === widthPx) {
        applyCaptionWidth(widthPx);
        return;
      }

      // Apply with a guard so ResizeObserver callbacks caused by this change don't re-enter
      target.__mediaResizeApplying = true;
      try {
        target.style.width = widthPx + 'px';
        target.style.maxWidth = '100%';
      } finally {
        // schedule clearing the guard next tick so other observers can run afterwards
        requestAnimationFrame(() => { target.__mediaResizeApplying = false; });
      }

      applyCaptionWidth(widthPx);
    } catch (err) { /* ignore */ }
  };

  const ro = new ResizeObserver(sync);
  try { ro.observe(target); } catch (e) {}
  // still safe to observe media too (some browsers change media size independently),
  // but prefer observing the container first; observe media as a secondary target.
  try { if (mediaEl !== target) ro.observe(mediaEl); } catch (e) {}

  const mo = new MutationObserver(sync);
  try { mo.observe(mediaEl, { attributes: true, attributeFilter: ['style', 'class', 'width', 'src'] }); } catch (e) {}

  target.__mediaResizeObserver = ro;
  target.__mediaMutationObserver = mo;

  // initial sync
  requestAnimationFrame(sync);
}

/* ---------------------------
   Attach observers + wrap media into figure.custom-figure
   --------------------------- */
function attachObserversToAllFigures(root = document) {
  (root || document).querySelectorAll('img, video').forEach(media => {
    try {
      if (!media.closest('#root')) return;
      if (media.closest('figure.custom-figure')) {
        attachMediaResizeSync(media, media.closest('figure.custom-figure'));
        return;
      }

      let next = media.nextSibling;
      while (next && next.nodeType !== 1) next = next.nextSibling;
      const hasCaption = next && next.classList && next.classList.contains('ql-caption');

      const figure = document.createElement('figure');
      figure.className = 'custom-figure align-center';
      figure.setAttribute('contenteditable','false');

      const cs = window.getComputedStyle(media);
      const computedWidth = parseInt(cs.width, 10);
      if (computedWidth && computedWidth > 20) figure.style.width = computedWidth + 'px';

      const parent = media.parentElement;
      if (!parent) return;
      parent.insertBefore(figure, media);
      figure.appendChild(media);
      if (hasCaption) {
        figure.appendChild(next);
      } else {
        const caption = document.createElement('figcaption');
        caption.className = 'ql-caption';
        caption.setAttribute('contenteditable','true');
        caption.innerText = '';
        figure.appendChild(caption);
      }

      attachControls(figure);
      const innerMedia = figure.querySelector('img,video');
      if (innerMedia) attachMediaResizeSync(innerMedia, figure);

    } catch (e) { /* ignore per element */ }
  });

  (root || document).querySelectorAll('figure.custom-figure img, figure.custom-figure video').forEach(media => {
    try { attachMediaResizeSync(media, media.closest('figure.custom-figure')); } catch(e) {}
  });
}

attachObserversToAllFigures();
editor.on('text-change', (debounce(() => attachObserversToAllFigures(), 150)));

/* ---------------------------
   Modal UI logic (insert FigureBlot)
   --------------------------- */
function wireModal(opts) {
  const overlay = document.getElementById(opts.overlayId);
  const urlInput = document.getElementById(opts.urlId);
  const fileInput = document.getElementById(opts.fileId);
  const captionInput = document.getElementById(opts.captionId);
  const preview = document.getElementById(opts.previewId);
  const btnCancel = document.getElementById(opts.cancelId);
  const btnInsert = document.getElementById(opts.insertId);

  let selectedDataUrl = null; let lastSelectionIndex = 0;
  function openModal() {
    lastSelectionIndex = (editor.getSelection() && editor.getSelection().index) || editor.getLength();
    urlInput.value = ''; fileInput.value = ''; captionInput.value = ''; selectedDataUrl = null;
    preview.innerHTML = 'Preview';
    overlay.classList.add('active'); overlay.setAttribute('aria-hidden', 'false'); setTimeout(()=> urlInput.focus(), 50);
  }
  function closeModal() { overlay.classList.remove('active'); overlay.setAttribute('aria-hidden','true'); urlInput.value=''; fileInput.value=''; captionInput.value=''; preview.innerHTML='Preview'; selectedDataUrl = null; editor.focus(); }
  function updatePreview() { const url = urlInput.value.trim(); const src = selectedDataUrl || url; if (!src) { preview.innerHTML = 'Preview'; return; } preview.innerHTML = ''; if (opts.type === 'image') { const img = document.createElement('img'); img.src = src; img.alt = captionInput.value || 'Preview image'; preview.appendChild(img); } else { const video = document.createElement('video'); video.controls = true; video.src = src; video.playsInline = true; preview.appendChild(video); } }

  fileInput.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0]; if (!file) return;
    if (opts.type === 'image') {
      const reader = new FileReader(); reader.onload = (e) => { selectedDataUrl = e.target.result; urlInput.value=''; updatePreview(); }; reader.readAsDataURL(file);
    } else {
      try { const blobUrl = URL.createObjectURL(file); selectedDataUrl = blobUrl; urlInput.value=''; updatePreview(); } catch (err) { const reader = new FileReader(); reader.onload = (e) => { selectedDataUrl = e.target.result; urlInput.value=''; updatePreview(); }; reader.readAsDataURL(file); }
    }
  });

  urlInput.addEventListener('input', () => { selectedDataUrl = null; updatePreview(); });
  captionInput.addEventListener('input', updatePreview);
  btnCancel.addEventListener('click', closeModal);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
  overlay.addEventListener('keydown', (e) => { if (e.key === 'Escape') { e.preventDefault(); closeModal(); } if (e.key === 'Enter') { if (document.activeElement === fileInput) return; e.preventDefault(); btnInsert.click(); } });

  btnInsert.addEventListener('click', () => {
    const url = urlInput.value.trim(); const finalSrc = selectedDataUrl || url; const caption = captionInput.value.trim();
    if (!finalSrc) { preview.innerHTML = '<span style="color:#cc0000">Please provide a URL or upload a file.</span>'; urlInput.focus(); return; }

    const index = Math.max(0, lastSelectionIndex);
    const type = opts.type === 'video' || urlLooksLikeVideo(finalSrc) ? 'video' : 'image';
    editor.insertEmbed(index, 'figure', { url: finalSrc, type, caption: caption || '', width: '', align: 'center' }, Quill.sources.USER);
    editor.insertText(index + 1, '\n', Quill.sources.SILENT);
    editor.setSelection(index + 2, 0, Quill.sources.SILENT);
    setTimeout(() => attachObserversToAllFigures(), 60);
    markInserted(normalizeUrl(finalSrc));
    closeModal();
    return;
  });

  return { open: openModal };
}

const imageModal = wireModal({
  overlayId: 'quill-image-modal-overlay',
  urlId: 'quill-image-url',
  fileId: 'quill-image-file',
  captionId: 'quill-image-caption',
  previewId: 'quill-image-preview',
  cancelId: 'quill-image-cancel',
  insertId: 'quill-image-insert',
  type: 'image',
});
const videoModal = wireModal({
  overlayId: 'quill-video-modal-overlay',
  urlId: 'quill-video-url',
  fileId: 'quill-video-file',
  captionId: 'quill-video-caption',
  previewId: 'quill-video-preview',
  cancelId: 'quill-video-cancel',
  insertId: 'quill-video-insert',
  type: 'video'
});

/* ---------------------------
   Toolbar handlers
   --------------------------- */
const toolbar = editor.getModule('toolbar');
if (toolbar) {
  toolbar.addHandler('image', () => imageModal.open());
  toolbar.addHandler('video', () => videoModal.open());
  toolbar.addHandler('hr', () => {
    const range = editor.getSelection(true) || { index: editor.getLength(), length: 0 };
    editor.insertEmbed(range.index, 'hr', true, Quill.sources.USER);
    editor.insertText(range.index + 1, '\n', Quill.sources.SILENT);
    editor.setSelection(range.index + 2, 0, Quill.sources.SILENT);
  });
}

/* ---------------------------
   Tooltip system (unchanged)
   --------------------------- */
const TOOLTIP_MAP = { bold: 'Bold (Ctrl+B)', italic: 'Italic (Ctrl+I)', underline: 'Underline (Ctrl+U)', strike: 'Strikethrough', blockquote: 'Blockquote', 'code-block': 'Code block', 'header:1': 'Heading 1','header:2': 'Heading 2', 'list:ordered': 'Ordered list', 'list:bullet': 'Bulleted list', 'list:check': 'Checklist','script:sub': 'Subscript', 'script:super': 'Superscript','indent:-1': 'Decrease indent','indent:+1': 'Increase indent','direction:rtl': 'Right-to-left', 'align': 'Alignment', 'size': 'Font size', 'color': 'Text color', 'background': 'Background color','font': 'Font family', link: 'Insert link', image: 'Insert image', video: 'Insert video', formula: 'Insert formula', 'table-better': 'Table tools', clean: 'Remove formatting', undo: 'Undo (Ctrl+Z)', redo: 'Redo (Ctrl+Y / Ctrl+Shift+Z)' };
// create tooltip element (keep your TOOLTIP_MAP above)
const tooltipEl = document.createElement('div');
tooltipEl.className = 'ql-custom-tooltip';
document.body.appendChild(tooltipEl);

// keep your detectFormatFromNode() as-is if you want; using the original:
function detectFormatFromNode(node) {
  if (!node) return null;
  for (const cls of node.classList) {
    if (!cls.startsWith('ql-')) continue;
    const key = cls.slice(3);
    const val = node.getAttribute('value') || node.getAttribute('data-value');
    if (val !== null && val !== undefined && val !== '') return `${key}:${val}`;
    return key;
  }
  const picker = node.closest && node.closest('.ql-picker');
  if (picker) return 'align';
  return null;
}

// prefer dataset.tooltip, then aria-label, then format-map
function getTooltipTextForNode(node) {
  if (!node) return '';
  if (node.dataset && node.dataset.tooltip) return node.dataset.tooltip;
  if (node.getAttribute && node.getAttribute('aria-label')) return node.getAttribute('aria-label');
  const fmt = detectFormatFromNode(node);
  if (!fmt) return (node.innerText || '').trim() || '';
  if (TOOLTIP_MAP[fmt]) return TOOLTIP_MAP[fmt];
  const [k,v] = fmt.split(':');
  if (v) {
    if (k === 'header') return `Heading ${v}`;
    if (k === 'list') {
      if (v === 'ordered') return 'Ordered list';
      if (v === 'bullet') return 'Bulleted list';
      if (v === 'check') return 'Checklist';
    }
    if (k === 'script') return v === 'sub' ? 'Subscript' : 'Superscript';
    if (k === 'indent') return v === '-1' ? 'Decrease indent' : 'Increase indent';
  }
  return k.charAt(0).toUpperCase() + k.slice(1);
}

let mouseMoveHandler = null;
function positionTooltip(target, event) {
  const rect = target.getBoundingClientRect();
  tooltipEl.style.left = '0px';
  tooltipEl.style.top = '0px';
  const tw = tooltipEl.offsetWidth, th = tooltipEl.offsetHeight;
  let left, top;
  if (event && (event.clientX || event.clientY)) {
    left = event.clientX - tw/2;
    top = event.clientY - th - 12;
  } else {
    left = rect.left + (rect.width/2) - (tw/2);
    top = rect.top - th - 10;
  }
  const margin = 8;
  if (left < margin) left = margin;
  if (left + tw > window.innerWidth - margin) left = window.innerWidth - tw - margin;
  if (top < margin) top = rect.bottom + 12;
  tooltipEl.style.left = `${Math.round(left)}px`;
  tooltipEl.style.top = `${Math.round(top)}px`;
}

function showTooltip(target, event) {
  const text = getTooltipTextForNode(target);
  if (!text) return;
  tooltipEl.textContent = text;
  tooltipEl.classList.add('visible');
  positionTooltip(target, event);
  // attach a single mousemove handler for live positioning; keep one global reference
  mouseMoveHandler = (ev) => positionTooltip(target, ev);
  document.addEventListener('mousemove', mouseMoveHandler);
}

function hideTooltip() {
  tooltipEl.classList.remove('visible');
  tooltipEl.textContent = '';
  if (mouseMoveHandler) {
    document.removeEventListener('mousemove', mouseMoveHandler);
    mouseMoveHandler = null;
  }
}

function attachToolbarTooltips() {
  const toolbarEl = document.querySelector('.ql-toolbar');
  if (!toolbarEl) return;

  // candidate controls inside toolbar
  const controls = toolbarEl.querySelectorAll('button, .ql-picker, .ql-picker-label, select, input');

  controls.forEach(ctrl => {
    // skip if this element is already bound
    if (ctrl.dataset && ctrl.dataset.tooltipBound) return;

    // if any ancestor inside the toolbar is already bound, skip this element to prevent nested double-bind
    let anc = ctrl.parentElement;
    let skip = false;
    while (anc && anc !== toolbarEl) {
      if (anc.dataset && anc.dataset.tooltipBound) { skip = true; break; }
      anc = anc.parentElement;
    }
    if (skip) return;

    // mark this element as bound
    ctrl.dataset.tooltipBound = '1';

    // compute tooltip text and store it on dataset (remove title to avoid native tooltip)
    const title = getTooltipTextForNode(ctrl) || '';
    if (title) {
      ctrl.dataset.tooltip = title;
      ctrl.setAttribute('aria-label', title); // keep accessible
      ctrl.removeAttribute('title'); // IMPORTANT: remove native title so browser tooltip won't show
    }

    // bind events (single set)
    ctrl.addEventListener('mouseenter', (ev) => showTooltip(ctrl, ev));
    ctrl.addEventListener('mouseleave', hideTooltip);
    ctrl.addEventListener('click', hideTooltip);
  });
}

// initial attach + observe
attachToolbarTooltips();
const toolbarObserver = new MutationObserver(() => attachToolbarTooltips());
const tb = document.querySelector('.ql-toolbar');
if (tb) toolbarObserver.observe(tb, { childList: true, subtree: true });

/* ---------------------------
   Drag and drop support (images + native videos) -> inserts FigureBlot
   --------------------------- */
const editorCard = document.querySelector('.editor-card');
const editorRoot = editor.root;

editorRoot.addEventListener("dragover", (e) => {
  e.preventDefault();
  editorCard.classList.add("drag-over");
  editorRoot.classList.add("drag-target");
});

editorRoot.addEventListener("dragleave", (e) => {
  editorCard.classList.remove("drag-over");
  editorRoot.classList.remove("drag-target");
});

editorRoot.addEventListener("drop", (e) => {
  e.preventDefault();
  editorCard.classList.remove("drag-over");
  editorRoot.classList.remove("drag-target");

  if (!e.dataTransfer) return;
  const file = e.dataTransfer.files && e.dataTransfer.files[0];
  const range = editor.getSelection(true) || { index: editor.getLength(), length: 0 };
  if (!file) return;

  if (file.type.startsWith("image/")) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      editor.insertEmbed(range.index, 'figure', { url: evt.target.result, type: 'image', caption: '' }, Quill.sources.USER);
      editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
      setTimeout(() => attachObserversToAllFigures(), 60);
      markInserted(normalizeUrl(evt.target.result));
    };
    reader.readAsDataURL(file);
    return;
  }

  if (file.type.startsWith("video/")) {
    try {
      const blobUrl = URL.createObjectURL(file);
      editor.insertEmbed(range.index, "figure", { url: blobUrl, type: 'video', caption: '' }, Quill.sources.USER);
      editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
      attachObserversToAllFigures();
      blobUrlTracker.add(blobUrl);
      markInserted(normalizeUrl(blobUrl));
    } catch (err) {
      const reader = new FileReader();
      reader.onload = (evt) => {
        editor.insertEmbed(range.index, "figure", { url: evt.target.result, type: 'video', caption: '' }, Quill.sources.USER);
        editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
        attachObserversToAllFigures();
        markInserted(normalizeUrl(evt.target.result));
      };
      reader.readAsDataURL(file);
    }
    return;
  }
});

/* ---------------------------
   Controls attachment for figure (toolbar, resize handle, caption edit)
   --------------------------- */
function attachControls(figureEl) {
  if (!figureEl || figureEl.__controlsAttached) return;
  figureEl.__controlsAttached = true;

  figureEl.style.position = getComputedStyle(figureEl).position === 'static' ? 'relative' : figureEl.style.position;
  if (!figureEl.style.width) figureEl.style.width = '320px';

  const handle = document.createElement('div');
  handle.className = 'fig-resize-handle';
  figureEl.appendChild(handle);

  const toolbarEl = document.createElement('div');
  toolbarEl.className = 'figure-toolbar';
  toolbarEl.innerHTML = `
    <button data-action="align-left" title="Align left">L</button>
    <button data-action="align-center" title="Align center">C</button>
    <button data-action="align-right" title="Align right">R</button>
    <button data-action="edit-caption" title="Edit caption">âœŽ</button>
    <button data-action="remove" title="Remove">ðŸ—‘</button>
  `;
  figureEl.appendChild(toolbarEl);

  figureEl.addEventListener('click', (evt) => {
    if (evt.target.tagName && evt.target.tagName.toLowerCase() === 'figcaption') {
      figureEl.classList.add('selected');
      return;
    }
    document.querySelectorAll('figure.custom-figure').forEach(f => f.classList.remove('selected'));
    figureEl.classList.add('selected');
  });

  editor.root.addEventListener('click', (e) => {
    const el = e.target.closest && e.target.closest('figure.custom-figure');
    if (!el) document.querySelectorAll('figure.custom-figure').forEach(f => f.classList.remove('selected'));
  });

  toolbarEl.addEventListener('click', (ev) => {
    const action = ev.target.closest('button')?.dataset?.action;
    if (!action) return;
    ev.stopPropagation();

    if (action === 'remove') {
      try {
        const blot = Quill.find(figureEl);
        if (blot) {
          const idx = editor.getIndex(blot);
          editor.deleteText(idx, 1, Quill.sources.USER);
        } else {
          figureEl.remove();
        }
      } catch (e) {
        try { figureEl.remove(); } catch(e) {}
      }
    } else if (action === 'edit-caption') {
      const caption = figureEl.querySelector('.ql-caption, figcaption');
      if (caption) {
        editor.disable();
        caption.focus();
        const range = document.createRange();
        range.selectNodeContents(caption);
        range.collapse(false);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }
    } else if (action.startsWith('align-')) {
      figureEl.classList.remove('align-left','align-center','align-right');
      const alignType = action.split('-')[1];
      if (alignType === 'center') figureEl.classList.add('align-center');
      else if (alignType === 'left') figureEl.classList.add('align-left');
      else if (alignType === 'right') figureEl.classList.add('align-right');

      try {
        const blot = Quill.find(figureEl);
        if (blot) {
          const idx = editor.getIndex(blot);
          const val = FigureBlot.value(figureEl);
          editor.deleteText(idx, 1, Quill.sources.SILENT);
          editor.insertEmbed(idx, 'figure', val, Quill.sources.USER);
        }
      } catch (e) {}
    }
  });

  const captionEl = figureEl.querySelector('.ql-caption, figcaption');
  if (captionEl) {
    captionEl.addEventListener('focus', (e) => {
      e.stopPropagation();
      figureEl.classList.add('selected');
      try { editor.disable(); } catch(e) {}
    });
    captionEl.addEventListener('blur', (e) => {
      try { editor.enable(); } catch(e) {}
      try {
        const blot = Quill.find(figureEl);
        if (blot) {
          const idx = editor.getIndex(blot);
          const val = FigureBlot.value(figureEl);
          editor.deleteText(idx, 1, Quill.sources.SILENT);
          editor.insertEmbed(idx, 'figure', val, Quill.sources.USER);
        }
      } catch (err) {}
    });
    captionEl.addEventListener('keydown', (e) => e.stopPropagation());
    captionEl.addEventListener('mousedown', (e) => e.stopPropagation());
  }

  // pointer-based resize
  let pointerId = null, startX = 0, startW = 0;
  handle.addEventListener('pointerdown', (ev) => {
    ev.preventDefault();
    pointerId = ev.pointerId;
    try { handle.setPointerCapture(pointerId); } catch (e) {}
    startX = ev.clientX;
    startW = figureEl.getBoundingClientRect().width;
    figureEl.classList.add('resizing');
    document.body.style.userSelect = 'none';
  });

  handle.addEventListener('pointermove', (ev) => {
    if (pointerId !== ev.pointerId) return;
    const dx = ev.clientX - startX;
    let newW = Math.max(80, startW + dx);
    const editorWidth = editor.root.clientWidth;
    newW = Math.min(newW, editorWidth - 20);
    figureEl.style.width = newW + 'px';
  });

  handle.addEventListener('pointerup', (ev) => {
    if (pointerId !== ev.pointerId) return;
    try { handle.releasePointerCapture(pointerId); } catch(e){}
    pointerId = null;
    figureEl.classList.remove('resizing');
    document.body.style.userSelect = '';
    try {
      const blot = Quill.find(figureEl);
      if (blot) {
        const idx = editor.getIndex(blot);
        const val = FigureBlot.value(figureEl);
        val.width = figureEl.style.width || '';
        editor.deleteText(idx, 1, Quill.sources.SILENT);
        editor.insertEmbed(idx, 'figure', val, Quill.sources.USER);
      }
    } catch (err) {}
  });

  handle.addEventListener('pointercancel', () => {
    pointerId = null;
    figureEl.classList.remove('resizing');
    document.body.style.userSelect = '';
  });
}

/* Observe editor DOM for new figure nodes */
const mo = new MutationObserver((mutations) => {
  for (const m of mutations) {
    if (m.type === 'childList' && m.addedNodes.length) {
      m.addedNodes.forEach(node => {
        if (node.nodeType !== 1) return;
        if (node.matches && node.matches('figure.custom-figure')) attachControls(node);
        else attachObserversToAllFigures(node);
      });
    }
  }
});
mo.observe(editor.root, { childList: true, subtree: true });

attachObserversToAllFigures(editor.root);

/* ---------------------------
   Small helpers
   --------------------------- */
function debounce(fn, wait = 120) { let t; return function(...a){ clearTimeout(t); t = setTimeout(()=> fn.apply(this,a), wait); }; }

</script>
</body>
</html>
