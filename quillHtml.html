<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quill — Image + Caption (Fixed: nativeVideo)</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.css">

<style>
:root{--card-bg:#fff; --page-bg:#f6f7fb; --text:#2c3e50; --muted:#98a2b3; --ring:#dbe6ff; --ring-strong:#9ec5ff; --button-bg:#fafafa; --button-border:#e4e7ec; --button-hover:#eef4ff; --button-active:#cfe2ff; --shadow:0 10px 30px rgba(0,0,0,0.08);} 
*{box-sizing:border-box}
body{background:var(--page-bg);font-family:"Segoe UI", Roboto, system-ui, -apple-system, Arial, sans-serif;display:flex;justify-content:center;padding:42px 12px;color:var(--text)}
.editor-card{width:100%;max-width:1080px;border-radius:18px;background:var(--card-bg);box-shadow:var(--shadow);border:1px solid #eef0f4;position:relative}
.ql-toolbar.ql-snow{display:flex;flex-wrap:wrap;gap:6px;padding:8px 12px;border:none;border-bottom:1px solid #eee;background:#fff;align-items:center;box-shadow:0 2px 4px rgba(0,0,0,0.04);border-radius:18px 18px 0 0}
.ql-toolbar .ql-formats{background:#fff;border:1px solid var(--button-border);border-radius:12px;padding:4px;display:flex;align-items:center;gap:2px}
.ql-toolbar.ql-snow button{height:32px;width:32px;border-radius:6px;display:flex;align-items:center;justify-content:center;transition:background .2s}
.ql-toolbar.ql-snow button:hover{background:#f5f5f5}
.ql-toolbar .ql-picker{height:32px;min-width:35px;font-size:14px;border-radius:6px;display:flex;align-items:center}
.ql-toolbar .ql-picker-label{display:flex;align-items:center;padding:0 8px}
.ql-toolbar .ql-picker-options{border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.1)}
.ql-toolbar button svg{width:16px;height:16px}
.ql-container.ql-snow{border:none;border-radius:0 0 14px 14px;box-shadow: inset 0 0 0 1px #eee}
.ql-editor{min-height:540px;font-size:17px;line-height:1.8;color:var(--text);background:#fff;border-radius:0 0 14px 14px;position:relative}
.ql-editor.ql-blank::before{color:#a3aab7;font-style:italic}
.ql-editor img,.ql-editor video{border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.08);margin:1rem auto;display:block;max-width:100%}
.video-resize-handle{width:12px;height:12px;background:#2196f3;position:absolute;right:0;bottom:0;cursor:nwse-resize;z-index:10;border-radius:3px}
.ql-snow .ql-table-better{align-items:center;padding:6px 10px;font-size:14px;border-radius:6px}
#char-count{position:absolute;bottom:-80px;right:16px;background:rgba(0,0,0,0.05);color:#555;padding:4px 10px;border-radius:12px;font-size:13px;pointer-events:none}
.ql-custom-tooltip{position:fixed;pointer-events:none;background:rgba(20,20,20,0.95);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;transform:translateY(-8px);transition:opacity .12s ease, transform .12s ease;opacity:0;z-index:9999;white-space:nowrap;box-shadow:0 6px 20px rgba(0,0,0,0.25)}
.ql-custom-tooltip.visible{opacity:1;transform:translateY(0)}
.ql-caption {
  display: block;           /* block so width applies reliably */
  margin: 6px auto 0;       /* center caption under the image/video */
  box-sizing: border-box;
  max-width: 100%;          /* never overflow container */
  white-space: normal;      /* allow wrapping */
  text-align: center;       /* keep caption text centered */
}
.ql-caption:focus{outline:none;box-shadow:0 0 0 3px rgba(66,153,225,0.12)}
.quill-modal-overlay{position:fixed;inset:0;background:rgba(10,10,10,0.45);display:none;align-items:center;justify-content:center;z-index:11000}
.quill-modal-overlay.active{display:flex}
.quill-modal{width:520px;max-width:calc(100% - 32px);background:#fff;border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.25);font-size:14px}
.quill-modal h3{Margin:0 0 10px;font-size:16px;color:var(--text)}
.quill-modal .row{display:flex;gap:10px;margin-bottom:10px;align-items:center}
.quill-modal label{display:block;width:100%;font-size:13px;color:var(--muted)}
.quill-modal input[type="text"],.quill-modal input[type="file"],.quill-modal textarea{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e6e9ee;background:#fbfbfb;font-size:14px}
.quill-modal .preview{width:100%;height:220px;border-radius:8px;background:#fafafa;display:flex;align-items:center;justify-content:center;overflow:hidden;border:1px dashed #e6e9ee}
.quill-modal .preview img,.quill-modal .preview video{max-width:100%;max-height:100%;display:block}
.quill-modal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
.btn{padding:8px 12px;border-radius:8px;border:1px solid var(--button-border);background:var(--button-bg);cursor:pointer}
.btn.primary{background:linear-gradient(180deg,#1e90ff,#147de8);color:#fff;border:1px solid rgba(0,0,0,0.08)}
.btn.ghost{background:transparent}
@media (max-width:520px){.quill-modal{padding:12px}.quill-modal .preview{height:160px}}
.editor-card.drag-over{outline:3px dashed rgba(30,144,255,0.22);box-shadow:0 12px 36px rgba(20,50,120,0.06)}
.ql-editor.drag-target{background-image:linear-gradient(90deg,rgba(30,144,255,0.03),rgba(30,144,255,0.01))}
.ql-hr { box-sizing: content-box; height: 0; border: 0; border-top: 1px solid #DFE3E7; }
</style>
</head>
<body>
<div class="editor-card">
  <div id="root"></div>
  <div id="char-count">Characters: 0</div>
</div>

<!-- Image modal -->
<div id="quill-image-modal-overlay" class="quill-modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="quill-modal" role="document" aria-labelledby="quill-image-modal-title">
    <h3 id="quill-image-modal-title">Insert image (optional caption)</h3>
    <div class="row">
      <label>Image URL<input id="quill-image-url" type="text" placeholder="https://example.com/image.jpg" /></label>
    </div>
    <div class="row">
      <label>Or upload file<input id="quill-image-file" type="file" accept="image/*" /></label>
    </div>
    <div class="row">
      <label>Caption (optional)<input id="quill-image-caption" type="text" placeholder="Write a caption (optional)" /></label>
    </div>
    <div class="row"><div class="preview" id="quill-image-preview">Preview</div></div>
    <div class="actions">
      <button id="quill-image-cancel" class="btn ghost" type="button">Cancel</button>
      <button id="quill-image-insert" class="btn primary" type="button">Insert</button>
    </div>
  </div>
</div>

<!-- Video modal (now includes alignment) -->
<div id="quill-video-modal-overlay" class="quill-modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="quill-modal" role="document" aria-labelledby="quill-video-modal-title">
    <h3 id="quill-video-modal-title">Insert video (optional caption)</h3>
    <div class="row">
      <label>Video URL<input id="quill-video-url" type="text" placeholder="https://example.com/video.mp4" /></label>
    </div>
    <div class="row">
      <label>Or upload file<input id="quill-video-file" type="file" accept="video/*" /></label>
    </div>
    <div class="row">
      <label>Caption (optional)<input id="quill-video-caption" type="text" placeholder="Write a caption (optional)" /></label>
    </div>
    <div class="row"><div class="preview" id="quill-video-preview">Preview</div></div>
    <div class="actions">
      <button id="quill-video-cancel" class="btn ghost" type="button">Cancel</button>
      <button id="quill-video-insert" class="btn primary" type="button">Insert</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
<script src="https://cdn.jsdelivr.net/npm/quill-table-better@1/dist/quill-table-better.js"></script>
<script src="https://cdn.jsdelivr.net/gh/scrapooo/quill-resize-module@1.0.2/dist/quill-resize-module.js"></script>

<script>
/* ---------------------------
   Setup / Register modules
   --------------------------- */
const Icons = Quill.import('ui/icons');
Icons['undo'] = `<svg viewBox="0 0 24 24"><path d="M7 7v4H3M3 11a9 9 0 1 1 3 6.7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
Icons['redo'] = `<svg viewBox="0 0 24 24"><path d="M17 7v4h4M21 11a9 9 0 1 0-3 6.7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
Icons['hr'] = `<svg viewBox="0 0 24 24" width="16" height="16">
  <line x1="4" y1="12" x2="20" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
</svg>`;

if (window.QuillTableBetter) Quill.register({ 'modules/table-better': QuillTableBetter }, true);
if (window.QuillResizeModule) {
  Quill.register('modules/imageResize', QuillResizeModule);
  Quill.register('modules/videoResize', QuillResizeModule);
}

/* Patch ResizePlugin.destory -> destroy (safety) */
(function patchResizePlugin() {
  if (!window.QuillResizeModule || !window.QuillResizeModule.ResizePlugin) return;
  const RP = window.QuillResizeModule.ResizePlugin.prototype;
  if (RP.destory) {
    RP.destroy = function () {
      try {
        if (this.resizer && this.container && this.container.contains(this.resizer)) {
          this.container.removeChild(this.resizer);
        }
      } catch (err) {}
      window.removeEventListener("mouseup", this.endResize);
      window.removeEventListener("mousemove", this.resizing);
      this.resizer = null;
    };
  }
  RP.destory = function () {
    this.destroy();
  };
})();

/* ---------------------------
   Horizontal rule blot
   --------------------------- */
const BlockEmbed = Quill.import('blots/block/embed');
class HorizontalLineBlot extends BlockEmbed {
  static create() {
    const node = super.create();
    node.setAttribute('contenteditable', false);
    return node;
  }
}
HorizontalLineBlot.blotName = 'hr';
HorizontalLineBlot.tagName = 'hr';
HorizontalLineBlot.className = 'ql-hr';
Quill.register(HorizontalLineBlot);

/* ---------------------------
   Caption blot (block)
   --------------------------- */
const Block = Quill.import('blots/block');
class CaptionBlot extends Block {
  static create(value = '') {
    const node = super.create();
    node.setAttribute('contenteditable', true);
    node.className = 'ql-caption';
    node.innerText = value || '';
    return node;
  }
  static value(node) {
    return node.innerText || '';
  }
}
CaptionBlot.blotName = 'caption';
CaptionBlot.tagName = 'div';
Quill.register(CaptionBlot);

/* ---------------------------
   NativeVideoBlot — simple native <video> (no wrapper)
   --------------------------- */
class NativeVideoBlot extends BlockEmbed {
  static create(value) {
    const node = super.create();
    node.setAttribute('contenteditable', false);

    const url = typeof value === 'string' ? value : (value && value.url) || '';

    const video = document.createElement('video');
    video.src = url;
    video.controls = true;
    video.playsInline = true;
    video.style.display = 'block';
    video.style.maxWidth = '100%';
    video.style.margin = '0 auto';

    node.appendChild(video);

    return node;
  }

  static value(node) {
    const v = node.querySelector('video');
    return v ? v.getAttribute('src') : '';
  }
}
NativeVideoBlot.blotName = 'nativeVideo';
NativeVideoBlot.tagName = 'div';
NativeVideoBlot.className = 'ql-native-video';
Quill.register(NativeVideoBlot);

/* ---------------------------
   Initialize Quill editor
   --------------------------- */
const editor = new Quill('#root', {
  theme: 'snow',
  placeholder: 'Start writing your content...',
  modules: {
    toolbar: {
      container: [
        ['bold','italic','underline','strike'],
        ['blockquote','code-block'],
        [{ 'header': 1 }, { 'header': 2 }],
        [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }],
        [{ 'script': 'sub'}, { 'script': 'super' }],
        [{ 'indent': '-1'},{ 'indent': '+1' }],
        [{ 'direction': 'rtl' }],
        [{ 'align': [] }],
        [{ 'size': ['small', false, 'large', 'huge'] }],
        [{ 'color': [] }, { 'background': [] }],
        [{ 'font': [] }],
        ['link','image','video','hr'],
        ['table-better'],
        ['clean'],
        ['undo','redo']
      ],
      handlers: {
        undo: () => editor.history.undo(),
        redo: () => editor.history.redo()
      }
    },
    history: { delay: 1000, maxStack: 500, userOnly: true },
    'table-better': { toolbarTable: true, menus: ['column','row','merge','table','cell','wrap','copy','delete'] },
    keyboard: { bindings: window.QuillTableBetter ? QuillTableBetter.keyboardBindings : {} },
    imageResize: { displaySize: true },
    videoResize: {}
  }
});

window.__quill = editor; // debugging

/* ---------------------------
   Character count
   --------------------------- */
const charCountEl = document.getElementById('char-count');
function updateCharCount() {
  const text = editor.getText().replace(/\n$/, '');
  charCountEl.textContent = `Characters: ${text.length}`;
}
updateCharCount();
editor.on('text-change', updateCharCount);

/* ---------------------------
   Helpers & dedupe store
   --------------------------- */
const recentInserts = new Map();
const RECENT_TTL = 3000;
function markInserted(key) { if (!key) return; recentInserts.set(key, Date.now()); setTimeout(() => recentInserts.delete(key), RECENT_TTL + 200); }
function wasRecentlyInserted(key) { if (!key) return false; const t = recentInserts.get(key); return t && (Date.now() - t) < RECENT_TTL; }

function normalizeUrl(u) {
  try { const url = new URL(u, location.href); url.hash = ''; return url.toString(); } catch (err) { return String(u).trim(); }
}
function urlLooksLikeImage(url) { return /\.(png|jpe?g|gif|webp|bmp|svg)(\?.*)?$/i.test(url); }
function urlLooksLikeVideo(url) { return /\.(mp4|webm|ogg|mov|m4v|3gp)(\?.*)?$/i.test(url); }

/* ---------------------------
   Blob tracker and cleanup
   --------------------------- */
const blobUrlTracker = new Set();
const domCleanupObserver = new MutationObserver((mutations) => {
  for (const m of mutations) {
    for (const node of m.removedNodes) {
      if (node.nodeType !== 1) continue;
      const videos = node.tagName === 'VIDEO' ? [node] : Array.from(node.querySelectorAll('video'));
      for (const v of videos) {
        try {
          const s = v.src || '';
          if (s && s.startsWith('blob:') && blobUrlTracker.has(s)) {
            try { URL.revokeObjectURL(s); } catch(e){}
            blobUrlTracker.delete(s);
          }
        } catch (e) {}
      }
    }
  }
});
domCleanupObserver.observe(document.querySelector('#root'), { childList: true, subtree: true });

/* ---------------------------
   Clipboard matchers (image + nativeVideo)
   --------------------------- */
try {
  const Clipboard = editor.getModule('clipboard');
  if (Clipboard && Clipboard.addMatcher) {
    const Delta = Quill.import('delta');
    Clipboard.addMatcher('IMG', (node, delta) => {
      const src = node.getAttribute('src') || '';
      if (!src) return delta;
      if (wasRecentlyInserted(normalizeUrl(src))) return new Delta();
      markInserted(normalizeUrl(src));
      return new Delta().insert({ image: src }).insert('\n');
    });
    Clipboard.addMatcher('VIDEO', (node, delta) => {
      // prefer <video src> or <video><source src=...>
      const src = node.getAttribute('src') || (node.querySelector('source') && node.querySelector('source').getAttribute('src')) || '';
      if (!src) return delta;
      if (wasRecentlyInserted(normalizeUrl(src))) return new Delta();
      markInserted(normalizeUrl(src));
      // insert our nativeVideo embed (not the fragile wrapper)
      return new Delta().insert({ nativeVideo: src }).insert('\n');
    });
  }
} catch (e) { /* ignore */ }

/* ---------------------------
   attachMediaResizeSync
   - works for image or video elements. For native media we attach to the element itself.
   --------------------------- */
function attachMediaResizeSync(mediaEl, containerEl) {
  if (!mediaEl) return;
  const target = containerEl || mediaEl;
  if (target.__mediaResizeAttached) return;
  target.__mediaResizeAttached = true;

  const applyCaptionWidth = (widthPx) => {
    try {
      let next = mediaEl.nextSibling;
      while (next && next.nodeType !== 1) next = next.nextSibling;
      if (next && next.classList && next.classList.contains('ql-caption')) {
        if (widthPx && widthPx > 0) {
          next.style.width = widthPx + 'px';
          next.style.maxWidth = '100%';
        } else {
          next.style.width = 'auto';
        }
        next.style.marginLeft = next.style.marginRight = 'auto';
        next.style.boxSizing = 'border-box';
      }
    } catch (err) { /* ignore */ }
  };

  const sync = () => {
    try {
      const rect = mediaEl.getBoundingClientRect();
      let widthPx = Math.round(rect.width);
      if (!widthPx || widthPx === 0) {
        const cs = window.getComputedStyle(mediaEl);
        widthPx = parseInt(cs.width, 10) || 0;
      }
      if (widthPx > 0) {
        target.style.width = widthPx + 'px';
        target.style.maxWidth = '100%';
      } else {
        target.style.width = 'auto';
      }
      applyCaptionWidth(widthPx);
    } catch (err) { /* ignore */ }
  };

  const ro = new ResizeObserver(sync);
  try { ro.observe(mediaEl); } catch (e) {}
  const parent = mediaEl.parentElement;
  if (parent && parent !== target) { try { ro.observe(parent); } catch (e) {} }

  const mo = new MutationObserver(sync);
  try { mo.observe(mediaEl, { attributes: true, attributeFilter: ['style', 'class', 'width', 'src'] }); } catch (e) {}

  target.__mediaResizeObserver = ro;
  target.__mediaMutationObserver = mo;

  requestAnimationFrame(sync);
}

/* Attach observers to images and native videos inside editor */
function attachObserversToAllFigures(root = document) {
  (root || document).querySelectorAll('img').forEach(img => {
    try {
      if (!img.closest('#root')) return;
      attachMediaResizeSync(img, img);
    } catch (e) {}
  });
  (root || document).querySelectorAll('video').forEach(video => {
    try {
      if (!video.closest('#root')) return;
      attachMediaResizeSync(video, video);
    } catch (e) {}
  });
}
attachObserversToAllFigures();
editor.on('text-change', (debounce(() => attachObserversToAllFigures(), 150)));

/* ---------------------------
   Modal UI logic (image + video) — unified wireModal
   --------------------------- */
function wireModal(opts) {
  const overlay = document.getElementById(opts.overlayId);
  const urlInput = document.getElementById(opts.urlId);
  const fileInput = document.getElementById(opts.fileId);
  const captionInput = document.getElementById(opts.captionId);
  const preview = document.getElementById(opts.previewId);
  const btnCancel = document.getElementById(opts.cancelId);
  const btnInsert = document.getElementById(opts.insertId);
  const alignSelect = opts.alignId ? document.getElementById(opts.alignId) : null;

  let selectedDataUrl = null; let lastSelectionIndex = 0;
  function openModal() {
    lastSelectionIndex = (editor.getSelection() && editor.getSelection().index) || editor.getLength();
    urlInput.value = ''; fileInput.value = ''; captionInput.value = ''; selectedDataUrl = null; if (alignSelect) alignSelect.value = '';
    preview.innerHTML = 'Preview';
    overlay.classList.add('active'); overlay.setAttribute('aria-hidden', 'false'); setTimeout(()=> urlInput.focus(), 50);
  }
  function closeModal() { overlay.classList.remove('active'); overlay.setAttribute('aria-hidden','true'); urlInput.value=''; fileInput.value=''; captionInput.value=''; preview.innerHTML='Preview'; selectedDataUrl = null; editor.focus(); }
  function updatePreview() { const url = urlInput.value.trim(); const src = selectedDataUrl || url; if (!src) { preview.innerHTML = 'Preview'; return; } preview.innerHTML = ''; if (opts.type === 'image') { const img = document.createElement('img'); img.src = src; img.alt = captionInput.value || 'Preview image'; preview.appendChild(img); } else { const video = document.createElement('video'); video.controls = true; video.src = src; video.playsInline = true; preview.appendChild(video); } }

  fileInput.addEventListener('change', (ev) => {
    const file = ev.target.files && ev.target.files[0]; if (!file) return;
    if (opts.type === 'image') {
      const reader = new FileReader(); reader.onload = (e) => { selectedDataUrl = e.target.result; urlInput.value=''; updatePreview(); }; reader.readAsDataURL(file);
    } else {
      try { const blobUrl = URL.createObjectURL(file); selectedDataUrl = blobUrl; urlInput.value=''; updatePreview(); } catch (err) { const reader = new FileReader(); reader.onload = (e) => { selectedDataUrl = e.target.result; urlInput.value=''; updatePreview(); }; reader.readAsDataURL(file); }
    }
  });

  urlInput.addEventListener('input', () => { selectedDataUrl = null; updatePreview(); });
  captionInput.addEventListener('input', updatePreview);
  btnCancel.addEventListener('click', closeModal);
  overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
  overlay.addEventListener('keydown', (e) => { if (e.key === 'Escape') { e.preventDefault(); closeModal(); } if (e.key === 'Enter') { if (document.activeElement === fileInput) return; e.preventDefault(); btnInsert.click(); } });

  btnInsert.addEventListener('click', () => {
    const url = urlInput.value.trim(); const finalSrc = selectedDataUrl || url; const caption = captionInput.value.trim();
    const align = alignSelect ? (alignSelect.value || '') : '';
    if (!finalSrc) { preview.innerHTML = '<span style="color:#cc0000">Please provide a URL or upload a file.</span>'; urlInput.focus(); return; }

    const index = Math.max(0, lastSelectionIndex);

    if (opts.type === 'image') {
      // native image + optional caption (same flow as before)
      editor.insertEmbed(index, 'image', finalSrc, Quill.sources.USER);
      if (align) editor.formatLine(index, 'align', align, Quill.sources.USER);

      let nextIndex = index + 1;
      if (caption) {
        editor.insertEmbed(nextIndex, 'caption', caption, Quill.sources.USER);
        nextIndex = nextIndex + 1;
      }
      editor.insertText(nextIndex, '\n', Quill.sources.SILENT);
      editor.setSelection(nextIndex + 1, 0, Quill.sources.SILENT);

      setTimeout(() => attachObserversToAllFigures(), 60);
      markInserted(normalizeUrl(finalSrc));
      closeModal();
      return;
    } else {
      // nativeVideo embed + optional caption (same image logic)
      editor.insertEmbed(index, 'nativeVideo', finalSrc, Quill.sources.USER);
      if (align) editor.formatLine(index, 'align', align, Quill.sources.USER);

      let nextIndex = index + 1;
      if (caption) {
        editor.insertEmbed(nextIndex, 'caption', caption, Quill.sources.USER);
        nextIndex = nextIndex + 1;
      }
      editor.insertText(nextIndex, '\n', Quill.sources.SILENT);
      editor.setSelection(nextIndex + 1, 0, Quill.sources.SILENT);

      setTimeout(() => attachObserversToAllFigures(), 60);
      markInserted(normalizeUrl(finalSrc));
      closeModal();
      return;
    }
  });

  return { open: openModal };
}

const imageModal = wireModal({
  overlayId: 'quill-image-modal-overlay',
  urlId: 'quill-image-url',
  fileId: 'quill-image-file',
  captionId: 'quill-image-caption',
  previewId: 'quill-image-preview',
  cancelId: 'quill-image-cancel',
  insertId: 'quill-image-insert',
  type: 'image',
});
const videoModal = wireModal({
  overlayId: 'quill-video-modal-overlay',
  urlId: 'quill-video-url',
  fileId: 'quill-video-file',
  captionId: 'quill-video-caption',
  previewId: 'quill-video-preview',
  cancelId: 'quill-video-cancel',
  insertId: 'quill-video-insert',
  type: 'video'
});

/* ---------------------------
   Toolbar handlers
   --------------------------- */
const toolbar = editor.getModule('toolbar');
if (toolbar) {
  toolbar.addHandler('image', () => imageModal.open());
  toolbar.addHandler('video', () => videoModal.open());
  toolbar.addHandler('hr', () => {
    const range = editor.getSelection(true) || { index: editor.getLength(), length: 0 };
    editor.insertEmbed(range.index, 'hr', true, Quill.sources.USER);
    editor.insertText(range.index + 1, '\n', Quill.sources.SILENT);
    editor.setSelection(range.index + 2, 0, Quill.sources.SILENT);
  });
}

/* ---------------------------
   Tooltip system (unchanged)
   --------------------------- */
const TOOLTIP_MAP = { bold: 'Bold (Ctrl+B)', italic: 'Italic (Ctrl+I)', underline: 'Underline (Ctrl+U)', strike: 'Strikethrough', blockquote: 'Blockquote', 'code-block': 'Code block', 'header:1': 'Heading 1','header:2': 'Heading 2', 'list:ordered': 'Ordered list', 'list:bullet': 'Bulleted list', 'list:check': 'Checklist','script:sub': 'Subscript', 'script:super': 'Superscript','indent:-1': 'Decrease indent','indent:+1': 'Increase indent','direction:rtl': 'Right-to-left', 'align': 'Alignment', 'size': 'Font size', 'color': 'Text color', 'background': 'Background color','font': 'Font family', link: 'Insert link', image: 'Insert image', video: 'Insert video', formula: 'Insert formula', 'table-better': 'Table tools', clean: 'Remove formatting', undo: 'Undo (Ctrl+Z)', redo: 'Redo (Ctrl+Y / Ctrl+Shift+Z)' };
const tooltipEl = document.createElement('div'); tooltipEl.className = 'ql-custom-tooltip'; document.body.appendChild(tooltipEl);
function detectFormatFromNode(node) { if (!node) return null; for (const cls of node.classList) { if (!cls.startsWith('ql-')) continue; const key = cls.slice(3); const val = node.getAttribute('value') || node.getAttribute('data-value'); if (val !== null && val !== undefined && val !== '') return `${key}:${val}`; return key; } const picker = node.closest && node.closest('.ql-picker'); if (picker) return 'align'; return null; }
function getTooltipTextForNode(node) { if (!node) return ''; if (node.title) return node.title; if (node.dataset && node.dataset.tooltip) return node.dataset.tooltip; const fmt = detectFormatFromNode(node); if (!fmt) return node.innerText.trim() || node.getAttribute('aria-label') || ''; if (TOOLTIP_MAP[fmt]) return TOOLTIP_MAP[fmt]; const [k,v] = fmt.split(':'); if (v) { if (k === 'header') return `Heading ${v}`; if (k === 'list') { if (v==='ordered') return 'Ordered list'; if (v==='bullet') return 'Bulleted list'; if (v==='check') return 'Checklist'; } if (k === 'script') return v === 'sub' ? 'Subscript' : 'Superscript'; if (k === 'indent') return v === '-1' ? 'Decrease indent' : 'Increase indent'; } return k.charAt(0).toUpperCase() + k.slice(1); }
let mouseMoveHandler = null;
function positionTooltip(target, event){ const rect = target.getBoundingClientRect(); tooltipEl.style.left = '0px'; tooltipEl.style.top = '0px'; const tw = tooltipEl.offsetWidth, th = tooltipEl.offsetHeight; let left, top; if (event && (event.clientX || event.clientY)) { left = event.clientX - tw/2; top = event.clientY - th - 12; } else { left = rect.left + (rect.width/2) - (tw/2); top = rect.top - th - 10; } const margin = 8; if (left < margin) left = margin; if (left + tw > window.innerWidth - margin) left = window.innerWidth - tw - margin; if (top < margin) top = rect.bottom + 12; tooltipEl.style.left = `${Math.round(left)}px`; tooltipEl.style.top = `${Math.round(top)}px`; }
function showTooltip(target, event) { const text = getTooltipTextForNode(target); if (!text) return; tooltipEl.textContent = text; tooltipEl.classList.add('visible'); positionTooltip(target, event); mouseMoveHandler = (ev) => positionTooltip(target, ev); document.addEventListener('mousemove', mouseMoveHandler); }
function hideTooltip() { tooltipEl.classList.remove('visible'); tooltipEl.textContent = ''; if (mouseMoveHandler) { document.removeEventListener('mousemove', mouseMoveHandler); mouseMoveHandler = null; } }
function attachToolbarTooltips() { const toolbarEl = document.querySelector('.ql-toolbar'); if (!toolbarEl) return; const controls = toolbarEl.querySelectorAll('button, .ql-picker, .ql-picker-label, select, input'); controls.forEach(ctrl => { if (ctrl.dataset.tooltipBound) return; ctrl.dataset.tooltipBound = '1'; const title = getTooltipTextForNode(ctrl) || ''; if (title) ctrl.title = title; ctrl.addEventListener('mouseenter', (ev) => showTooltip(ctrl, ev)); ctrl.addEventListener('mouseleave', hideTooltip); ctrl.addEventListener('click', hideTooltip); }); }
attachToolbarTooltips();
const toolbarObserver = new MutationObserver(() => attachToolbarTooltips()); const tb = document.querySelector('.ql-toolbar'); if (tb) toolbarObserver.observe(tb, { childList: true, subtree: true });

/* ---------------------------
   Drag and drop support (images + native videos)
   --------------------------- */
const editorCard = document.querySelector('.editor-card');
const editorRoot = editor.root;

editorRoot.addEventListener("dragover", (e) => {
  e.preventDefault();
  editorCard.classList.add("drag-over");
  editorRoot.classList.add("drag-target");
});

editorRoot.addEventListener("dragleave", (e) => {
  editorCard.classList.remove("drag-over");
  editorRoot.classList.remove("drag-target");
});

editorRoot.addEventListener("drop", (e) => {
  e.preventDefault();
  editorCard.classList.remove("drag-over");
  editorRoot.classList.remove("drag-target");

  if (!e.dataTransfer) return;
  const file = e.dataTransfer.files && e.dataTransfer.files[0];
  const range = editor.getSelection(true) || { index: editor.getLength(), length: 0 };
  if (!file) return;

  // Handle image drop -> native image
  if (file.type.startsWith("image/")) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      editor.insertEmbed(range.index, "image", evt.target.result, Quill.sources.USER);
      editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
      setTimeout(() => attachObserversToAllFigures(), 60);
      markInserted(normalizeUrl(evt.target.result));
    };
    return;
  }

  // Handle video drop -> nativeVideo blot (supports blob:)
  if (file.type.startsWith("video/")) {
    try {
      const blobUrl = URL.createObjectURL(file);
      editor.insertEmbed(range.index, "nativeVideo", blobUrl, Quill.sources.USER);
      editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
      attachObserversToAllFigures();
      blobUrlTracker.add(blobUrl);
      markInserted(normalizeUrl(blobUrl));
    } catch (err) {
      const reader = new FileReader();
      reader.onload = (evt) => {
        editor.insertEmbed(range.index, "nativeVideo", evt.target.result, Quill.sources.USER);
        editor.insertText(range.index + 1, "\n", Quill.sources.SILENT);
        attachObserversToAllFigures();
        markInserted(normalizeUrl(evt.target.result));
      };
      reader.readAsDataURL(file);
    }
    return;
  }
});

/* ---------------------------
   Small helpers
   --------------------------- */
function debounce(fn, wait = 120) { let t; return function(...a){ clearTimeout(t); t = setTimeout(()=> fn.apply(this,a), wait); }; }

</script>
</body>
</html>
